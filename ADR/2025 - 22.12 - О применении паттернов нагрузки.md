ADR: 2025-12.4 - Анализ архитектурных паттернов для системы управления лояльностью клиентов
Дата: 13 декабря 2025 г.
Статус: Принято

Контекст
Для удовлетворения нефункциональных требований по производительности (PER01-PER04), масштабируемости (SCA01-SCA05), доступности (AVA01) и надежности (DUR01-DUR03) Системы управления лояльностью клиентов необходимо проанализировать и применить соответствующие архитектурные паттерны. Анализ проводится в рамках утверждённой архитектуры модульного монолита на Kotlin/Spring Boot с учётом планового роста до 250 000 пользователей.

Решение
Применение комбинации паттернов в различных компонентах модульного монолита:

Компонент системы	Применяемые паттерны	Решаемые ключевые требования
Просмотр баланса и акций	Кеширование + Индексы БД + Репликация на чтение	PER01, PER02
Начисление и списание баллов	Асинхронная обработка + Партиционирование истории	PER01, SCA01
Аналитика и отчёты	Отложенные вычисления + Денормализация витрин	PER03, PER04
Уведомления	Конвейер событий + Асинхронная обработка	PER01, SCA01
Ядро системы	Трехзвенная структура + Горизонтальное масштабирование	SCA01, DUR01
Стиль интеграции	Event-Driven Architecture (EDA) внутри монолита	PRN03, SCA01
Обоснование и детальный анализ паттернов
1. Трехзвенная структура (Layered Architecture)
Применение: Базовая архитектура каждого бизнес-модуля (loyalty-core, promotion-engine).

Контекст в монолите: Чёткое разделение на Controller (REST API), Service (бизнес-логика), Repository (доступ к данным) внутри каждого Gradle-модуля.

Плюсы:

Упрощение разработки и тестирования: Каждый слой имеет одну ответственность. Модульные тесты для Service не требуют поднятия всего контекста Spring.

Снижение связанности: Изменения в схеме БД (Repository) не затрагивают API-контракты (Controller).

Повторное использование: Бизнес-сервисы могут быть вызваны из разных контроллеров (REST, очереди, scheduled jobs).

Минусы:

Накладные расходы: Запрос проходит через несколько слоёв, что добавляет минимальную latency.

Риск "анаemic domain": Бизнес-логика может "растечься" по сервисам, если не следить за чистотой доменной модели (DDD).

Решаемые требования: PER01, SCA01, DUR01.

2. Кеширование и проблема инвалидации кеша
Применение: Redis для хранения правил начисления (F10), активных акций (F05), "горячих" балансов клиентов (F12).

Контекст в монолите: Использование Spring Cache с бэкендом Redis. Аннотации @Cacheable на методах сервисов.

Плюсы:

Радикальное ускорение чтения: Снижение времени ответа API с ~50 мс (запрос к БД) до ~1-5 мс (кеш).

Снятие нагрузки с БД: Частые запросы на просмотр акций и баланса не доходят до PostgreSQL.

Минусы:

Сложность согласованности (инвалидация): Основная проблема. Данные в кеше могут устареть.

Усложнение логики: Требуется механизм принудительной инвалидации при изменении данных.

Стратегия инвалидации:

TTL (Time-To-Live): 5 минут для данных, устойчивых к незначительной устарелости (список акций).

Инвалидация по событию: При изменении баланса (BonusAccruedEvent) или акции (PromotionUpdatedEvent) — отправка события в Spring ApplicationEventPublisher с последующим удалением ключа из Redis.

Решаемые требования: PER01, PER02, SCA01.

3. Толстый клиент (Rich Client)
Применение: Не применяется.

Обоснование отказа: Противоречит принципу PRN04 (User-Centric Design) и требованиям к поддержке браузеров (PLT01). Вся бизнес-логика (начисление баллов, сложные расчёты) должна выполняться на защищённом сервере для безопасности (SEC05) и контроля версий. Клиент (React SPA) остаётся "тонким" — отвечает только за отображение и сбор пользовательского ввода.

4. Деградация функциональности (Graceful Degradation)
Применение: Модуль начисления баллов (F03). При сбое интеграции с CRM или сервисом уведомлений (F11).

Сценарий: POS-система прислала событие о покупке.

Нормальный режим: Баллы начисляются → профиль обновляется в CRM → отправляется уведомление.

Режим деградации (CRM недоступен): Баллы начисляются, события SyncWithCrmEvent и SendNotificationEvent помещаются в таблицу-очередь failed_events для повторных попыток (retry). Ядро системы продолжает работу.

Плюсы:

Обеспечение AVA01: Критичная функция (учёт баллов) остаётся доступной.

Улучшение UX: Пользователь видит начисление баллов мгновенно, даже если уведомление придёт позже.

Минусы:

Временная несогласованность данных: Данные в CRM могут отставать. Требуются механизмы идемпотентности и повторной синхронизации.

Решаемые требования: AVA01, DUR01.

5. Масштабирование
Горизонтальное: Добавление инстансов приложения за балансировщиком нагрузки (начиная с SCA04, 100k пользователей). Использование stateless-архитектуры (сессии в Redis).

Вертикальное: Увеличение CPU/RAM для сервера БД PostgreSQL на этапе SCA02-SCA03 (10k-25k пользователей).

Во времени: Запуск джобов генерации сложных отчётов (F07) в окно технического обслуживания (AVA02, ночью).

Решаемые требования: SCA01-SCA05, PER04.

(Продолжение анализа остальных паттернов следует в том же формате...)

6. SOA и монолит
Применение: Выбран модульный монолит. Переход к SOA/микросервисам отложен до этапа SCA05 (250k пользователей).

Плюсы монолита на старте:

Простота разработки: Единая кодовая база, упрощённая отладка, сквозное тестирование.

Сильная согласованность данных: ACID-транзакции в рамках одной БД.

Отсутствие сетевых издержек: Вызов между модулями — это вызов метода, а не HTTP-запрос.

Минусы монолита:

Единая точка отказа: Сбой в одном модуле может "положить" всё приложение.

Сложность независимого масштабирования: Нельзя масштабировать только модуль аналитики, не масштабируя всё приложение.

Решаемые требования: SCA01, SCA02, PRN03.

17. Event-Driven Architecture (EDA)
Применение: Внутреннее взаимодействие между модулями монолита.

Контекст в Spring: Использование ApplicationEventPublisher и @EventListener. Пример событий: BonusAccruedEvent(userId, amount), PromotionActivatedEvent(promotionId).

Плюсы:

Слабая связанность: Модуль уведомлений подписывается на BonusAccruedEvent, не зная о существовании модуля начисления баллов.

Расширяемость: Новый функционал (например, модуль геймификации за достижения) можно добавить, просто подписавшись на нужные события, не меняя существующий код. Прямое отражение принципа PRN03.

Асинхронность и отказоустойчивость: Обработчики событий можно выполнять асинхронно (@Async), повышая отзывчивость.

Минусы:

Усложнение отладки: Поток выполнения становится нелинейным, сложнее трассировать причинно-следственные связи.

Гарантия доставки: В базовой реализации Spring Events события теряются при падении приложения. Для критичных событий требуется persistence (интеграция с Kafka или использование Spring Cloud Stream).

Решаемые требования: PRN03 (модульность), SCA01.

Последствия
Технические:

Требуется безупречное соблюдение границ модулей для сохранения преимуществ монолита.

Необходимо внедрение комплексного мониторинга (MON01) для отслеживания эффективности паттернов (hit-rate кеша, задержки репликации, очередь событий).

Операционные:

Упрощение: Одно приложение для развёртывания, настройки и мониторинга.

Усложнение: Отладка производительности требует профилирования всего приложения, а не отдельного сервиса.

Для бизнеса:

Система готова к уверенному росту до 100k пользователей (SCA04) с соблюдением SLA по доступности (AVA01).

Архитектура закладывает основу для эволюционного перехода к микросервисам, когда это станет экономически оправданным.

Рекомендации по реализации
Приоритет 1: Внедрить Трехзвенную структуру, Индексы БД и Асинхронную отправку уведомлений. Это фундамент.

Приоритет 2: После запуска добавить Кеширование (Redis) и Репликацию БД для чтения.

Приоритет 3: Внедрить Партиционирование таблицы transactions при приближении к 1 млн записей.

Обязательно: Каждое решение должно сопровождаться метриками (MON01). Например, график снижения времени отклика API /api/balance после внедрения кеша.