# ADR-2025-24.12  
## Анализ архитектурных паттернов для системы управления лояльностью клиентов

**Дата:** 24 декабря 2025 г.  
**Статус:** Принято

---

## Контекст

Для удовлетворения ключевых нефункциональных требований к **Системе управления лояльностью клиентов**:

- **Производительность:** PER01–PER04  
- **Масштабируемость:** SCA01–SCA05  
- **Доступность:** AVA01  
- **Надёжность:** DUR01–DUR03  

необходимо определить и применить набор композиционных архитектурных паттернов.

Анализ проводится в рамках утверждённой архитектуры **модульного монолита**  
(`Kotlin + Spring Boot`) с планируемым ростом нагрузки до **250 000 пользователей**.

---

## Решение

Принято решение использовать комбинацию архитектурных паттернов, ориентированных на **High Load**, в различных компонентах системы.

### Компоненты и применяемые паттерны

1. **Просмотр баланса и акций**
   - Паттерны: Кеширование, Индексы БД, Репликация на чтение  
   - Требования: `PER01`, `PER02`

2. **Начисление и списание баллов**
   - Паттерны: Асинхронная обработка, Партиционирование истории  
   - Требования: `PER01`, `SCA01`

3. **Аналитика и отчёты**
   - Паттерны: Отложенные вычисления, Денормализация витрин  
   - Требования: `PER03`, `PER04`

4. **Уведомления**
   - Паттерны: Конвейер событий, Асинхронная обработка  
   - Требования: `PER01`, `SCA01`

5. **Ядро системы**
   - Паттерны: Трёхзвенная структура, Горизонтальное масштабирование  
   - Требования: `SCA01`, `DUR01`

6. **Стиль интеграции модулей**
   - Паттерн: **Event-Driven Architecture (EDA)**  
   - Требования: `PRN03`, `SCA01`

---

## Обоснование и анализ паттернов

### 1. Трёхзвенная структура (Layered Architecture)

**Применение:**  
Базовая архитектура каждого бизнес-модуля (`loyalty-core`, `promotion-engine`).

**Реализация в Spring:**
- `@RestController`
- `@Service`
- `@Repository`

#### Плюсы
- Чёткое разделение ответственности
- Упрощение тестирования и поддержки
- Повторное использование бизнес-логики
- Упрощённый онбординг новых разработчиков

#### Минусы
- Дополнительная косвенность (indirection)
- Риск превращения в *Big Ball of Mud* при отсутствии дисциплины

**Решаемые требования:** `PER01`, `SCA01`, `DUR01`

---

### 2. Кеширование (Caching) и инвалидация кеша

**Применение:**
- Активные маркетинговые акции (F05)
- Сложные правила начисления (F10)
- Балансы активных клиентов (F12)

**Реализация:**
- `Spring Cache`
- Аннотации `@Cacheable`, `@CacheEvict`
- Redis как кеш-провайдер

#### Плюсы
- Существенное снижение времени отклика
- Снижение нагрузки на PostgreSQL
- Устойчивость к всплескам трафика

#### Минусы
- Проблема согласованности данных
- Дополнительный инфраструктурный компонент
- Повышенное потребление RAM

#### Стратегии инвалидации
- **TTL (2–5 минут)** — для данных, допускающих устаревание
- **Инвалидация по событию**
  - Генерация `PromotionUpdatedEvent`
  - Асинхронная очистка ключей Redis

**Решаемые требования:** `PER01`, `PER02`, `SCA01`

---

### 3. Толстый клиент (Rich / Fat Client)

**Статус:** ❌ Не применяется

#### Обоснование отказа
- Противоречит `PRN04` (User-Centric Design)
- Усложняет обновления и поддержку
- Повышает риски безопасности (`SEC05`)
- Привязывает UX к качеству сети

#### Альтернатива
- **Тонкий клиент**: `React / Next.js`
- Вся бизнес-логика выполняется на backend

**Решаемые требования:** `PRN04`, `PLT01`, `SEC05`

---

### 4. Деградация функциональности (Graceful Degradation)

**Применение:**
- Начисление баллов (F03)
- Интеграции с внешними системами (F09)

#### Плюсы
- Высокая доступность (`AVA01`)
- Лучший пользовательский опыт
- Повышение отказоустойчивости (`DUR01`)

#### Минусы
- Сложная логика retry и компенсаций
- Eventual Consistency
- Необходимость UX-обработки частичных отказов

#### Реализация
- Основной поток:
  - Сохранение транзакции
  - Публикация `BonusAccruedEvent`
- Фоновый поток:
  - Синхронизация с CRM
  - Retry через `pending_sync` с exponential backoff

**Решаемые требования:** `AVA01`, `DUR01`

---

### 5. Стратегии масштабирования

#### Горизонтальное масштабирование
- Добавление инстансов приложения
- Использование Load Balancer
- Этап: `SCA04` (100k пользователей)

**Плюсы:** линейный рост, отказоустойчивость  
**Минусы:** stateless-архитектура, Redis для сессий

---

#### Вертикальное масштабирование
- Увеличение ресурсов сервера
- Этап: `SCA02–SCA03`

**Плюсы:** простота  
**Минусы:** предел масштабирования, SPOF

---

#### Масштабирование во времени
- Ночные отчёты и аналитика
- Минимальная конкуренция за ресурсы

**Минусы:** данные не real-time

**Решаемые требования:**  
`SCA01–SCA05`, `PER04`, `AVA01`, `DUR01`

---

### 6. Монолит vs SOA / Микросервисы

**Выбранный стиль:** Модульный монолит

#### Плюсы
- Низкая операционная сложность
- ACID-транзакции
- Высокая производительность
- Быстрый Time-to-Market

#### Минусы
- Связанность стека
- Единый релиз
- Риск нарушения границ модулей

#### Почему не микросервисы сейчас
- Сетевые накладные расходы
- Высокая DevOps-сложность
- Противоречие `PER01–PER04` на старте

**Решаемые требования:**  
`SCA01`, `SCA02`, `PER01`, `PER04`, `PRN03`

---

## Последствия

### Технические
- Строгие границы модулей
- Комплексный мониторинг (`MON01`)
- Нагрузочные и интеграционные тесты

### Операционные
- Простой старт (1 артефакт, 1 БД)
- Новые компоненты: Redis, Kafka, реплики БД
- Необходимость centralized logging и tracing

### Для бизнеса
- Уверенный рост до 100k пользователей
- Готовность к эволюции через **Strangler Fig**

---

## Рекомендации по реализации

### Фаза 1 — Запуск
- Трёхзвенная архитектура
- Индексы БД
- Асинхронные уведомления

### Фаза 2 — До 25k пользователей
- Redis-кеш
- Реплики БД
- Ночная аналитика

### Фаза 3 — До 100k пользователей
- Партиционирование транзакций
- Горизонтальное масштабирование
- Полноценная EDA

### Непрерывно
- Метрики и графики (`MON01`)
- Анализ latency, hit-rate кеша, очередей событий
