ADR: 2025-24.12 - Анализ архитектурных паттернов для системы управления лояльностью клиентов
Дата: 24 декабря 2025 г.
Статус: Принято

**Контекст**
Для удовлетворения ключевых нефункциональных требований к Системе управления лояльностью клиентов — производительности (PER01-PER04), масштабируемости (SCA01-SCA05), доступности (AVA01) и надежности (DUR01-DUR03) — необходимо определить и применить набор композиционных архитектурных паттернов. Анализ ведётся в рамках утверждённой архитектуры модульного монолита на Kotlin/Spring Boot с плановым ростом нагрузки до 250 000 пользователей.

**Решение**
Принято решение о применении комбинации паттернов, направленных на обработку высокой нагрузки (High Load), в различных компонентах системы.
1. Компонент «Просмотр баланса и акций» → Паттерны: Кеширование, Индексы в БД, Репликация на чтение.
Решаемые требования: PER01, PER02.
2. Компонент «Начисление и списание баллов» → Паттерны: Асинхронная обработка, Партиционирование истории.
Решаемые требования: PER01, SCA01.
3. Компонент «Аналитика и отчёты» → Паттерны: Отложенные вычисления, Денормализация витрин.
Решаемые требования: PER03, PER04.
4. Компонент «Уведомления» → Паттерны: Конвейер событий, Асинхронная обработка.
Решаемые требования: PER01, SCA01.
5. Ядро системы (общее) → Паттерны: Трехзвенная структура, Горизонтальное масштабирование.
Решаемые требования: SCA01, DUR01.
6. Стиль интеграции модулей → Паттерн: Event-Driven Architecture (EDA).
Решаемые требования: PRN03, SCA01.

**Обоснование и анализ паттернов**
1. Трехзвенная структура (Layered Architecture)
Применение: Базовая архитектура каждого бизнес-модуля (loyalty-core, promotion-engine).

Реализация в Spring: Чёткое разделение на @RestController, @Service и @Repository компоненты внутри модуля.

Плюсы:
Чёткое разделение ответственности: Упрощает разработку, тестирование и поддержку кода. Изменения в одном слое минимально затрагивают другие.
Упрощение онбординга: Новая команда разработчиков легко понимает организацию кода.
Повторное использование бизнес-логики: Сервисный слой может быть вызван из REST API, обработчиков сообщений или scheduled jobs.

Минусы:
Дополнительная косвенность (indirection): Запрос проходит через несколько слоёв, что может добавить микрозадержки.
Риск "Anti-Corruption Layer" превратится в "Big Ball of Mud": Без строгой дисциплины слои могут начать обрастать несвойственными им обязанностями.

Решаемые требования: PER01, SCA01, DUR01.

3. Кеширование (Caching) и проблема инвалидации кеша
Применение: Кеширование в Redis активных маркетинговых акций (F05), сложных правил начисления (F10) и балансов наиболее активных клиентов (F12).
Реализация: Использование Spring Cache с аннотациями (@Cacheable, @CacheEvict) и Redis в качестве провайдера.
Плюсы:
Экстремальное снижение времени отклика: Доступ к данным из оперативной памяти (Redis) на порядки быстрее запросов к диску (PostgreSQL).
Снижение нагрузки на базу данных: Активные данные обслуживаются кешем, что позволяет БД сконцентрироваться на операциях записи и сложных запросах.
Повышение устойчивости к скачкам трафика: Кеш абсорбирует всплески запросов на чтение.
Минусы:
Проблема согласованности данных (Cache Invalidation): Самая сложная задача. Устаревшие данные в кеше приводят к бизнес-ошибкам (показ неактивной акции, неверный баланс).
Усложнение архитектуры: Добавляется новый критичный компонент (Redis), требующий мониторинга, резервирования и политик вытеснения данных.
Требует дополнительной памяти: Эффективный кеш потребляет значительные RAM-ресурсы.
Стратегия инвалидации:
TTL (Time-To-Live): Для данных, толерантных к некоторой устарелости (например, список акций). Устанавливается в 2-5 минут.
Инвалидация по событию (Write-Through/Write-Behind): При любом изменении данных (например, администратор изменил правило) генерируется доменное событие (PromotionUpdatedEvent). Слушатель этого события асинхронно очищает соответствующий ключ в Redis.
Решаемые требования: PER01, PER02, SCA01.

4. Толстый клиент (Rich Client / Fat Client)
Применение: Сознательно не применяется.
Обоснование отказа: Прямо противоречит принципу PRN04 (User-Centric Design) и требованиям к кроссплатформенности (PLT01, PLT02). Размещение бизнес-логики (расчёты начисления баллов, валидация) на клиенте:
Усложняет обновления и поддержку разных версий.
Создает риски для безопасности (SEC05), так как логику можно проанализировать или обойти.
Привязывает к качеству сетевого соединения.
Альтернатива: Применяется архитектура «Тонкий клиент» (React/Next.js), где клиент отвечает только за рендеринг UI и сбор действий пользователя, а вся бизнес-логика выполняется на защищённом бэкенде.
Решаемые требования: PRN04, PLT01, SEC05.
5. Деградация функциональности (Graceful Degradation)
Применение: В критически важном модуле начисления баллов (F03) и в интеграциях с внешними системами (F09).
Сценарий: При сбое или высокой задержке ответа от внешнего сервиса (например, CRM для обновления профиля или платёжного шлюза для списания).
Плюсы:
Обеспечение высокой доступности (AVA01) : Ядро системы (учёт транзакций) остаётся работоспособным, даже если периферийные функции временно недоступны.
Улучшенный пользовательский опыт: Клиент видит результат основной операции (начисление баллов) без ожидания, а фоновые процессы завершатся позже.
Повышение отказоустойчивости (DUR01) : Система не является "единой точкой отказа" для всей цепочки зависимых сервисов.
Минусы:
Усложнение логики приложения: Требуется реализация механизма отложенных повторов (retry), компенсирующих транзакций (Saga) и состояния "в процессе".
Временная несогласованность данных (Eventual Consistency): Данные в системе и во внешнем сервисе некоторое время могут расходиться, что требует механизмов синхронизации.
Необходимость явного информирования пользователя: Нужно продумать UX для ситуаций, когда часть функций временно недоступна.
Реализация:
Основной поток: Начисление баллов → сохранение в БД → публикация события BonusAccruedEvent.
Фоновый поток (асинхронный обработчик): Получает событие → пытается синхронизировать с CRM → при неудаче помещает задачу в таблицу pending_sync для повторной попытки через экспоненциальный backoff.
Решаемые требования: AVA01, DUR01.
6. Стратегии масштабирования (Scaling Strategies)
Применение: План адаптации инфраструктуры под прогнозируемый рост нагрузки (SCA01-SCA05).
Горизонтальное масштабирование (Scaling Out):
Что: Добавление новых инстансов (реплик) приложения за балансировщиком нагрузки (например, Nginx или облачный Load Balancer).
Когда: Начиная с этапа SCA04 (100k пользователей) для обработки пиковых нагрузок, особенно на чтение (просмотр баланса, истории).
Плюсы: Линейный рост производительности, повышение отказоустойчивости (нет единой точки отказа на уровне приложения).
Минусы: Требует stateless-архитектуры приложения (сессии в Redis), усложняет управление конфигурацией и развёртыванием.
Вертикальное масштабирование (Scaling Up):
Что: Увеличение вычислительных ресурсов (CPU, RAM, диск) у существующего сервера, особенно для базы данных.
Когда: На начальных этапах (SCA02-SCA03, до 25k пользователей) как наиболее простой и быстрый способ.
Плюсы: Простота реализации, не требует изменений в коде приложения.
Минусы: Имеет физический и финансовый предел, создаёт единую точку отказа.
Масштабирование во времени (Scaling over Time):
Что: Перенос ресурсоёмких задач (формирование сложных отчётов F07, расчёт агрегированной аналитики) на время наименьшей нагрузки пользователей.
Когда: На всех этапах, согласно окну техобслуживания AVA02 (ночное время).
Плюсы: Эффективное использование вычислительных ресурсов, отсутствие конкуренции с пользовательскими операциями за CPU/IO.
Минусы: Данные в отчётах не являются строго актуальными на момент формирования (Eventual Consistency).
Решаемые требования: SCA01-SCA05, PER04, AVA01, DUR01.
7. Архитектурные стили: SOA и Монолит
Применение: В качестве базового архитектурного стиля выбран Модульный Монолит. Переход к SOA/Микросервисам отложен до этапа SCA05 (250k пользователей).
Плюсы Монолита (в нашем контексте):
Низкая операционная сложность: Одно приложение для сборки, развёртывания, мониторинга и отладки.
Мощные транзакции и согласованность: ACID-транзакции в рамках одной БД гарантируют целостность данных при операциях с баллами (F03, F04).
Производительность межмодульного взаимодействия: Вызовы между модулями — это вызовы методов в памяти, а не сетевые RPC, что критично для PER01.
Быстрое прототипирование и вывод на рынок (Time-to-Market).
Минусы Монолита:
Связанность технологического стека: Все модули должны использовать одну версию фреймворка, библиотек и языка.
Сложность независимых развёртываний: Изменение в одном модуле требует пересборки и релиза всего приложения.
Риск нарушения границ модулей: Без строгой дисциплины легко создать скрытые зависимости между модулями, превратив монолит в "Big Ball of Mud".
Почему не SOA/Микросервисы сейчас?
Накладные расходы: Сетевые задержки, сериализация/десериализация, необходимость service discovery, resilience patterns (Circuit Breaker, Retry) противоречат требованиям PER01-PER04 на старте.
Высокий порог входа: Требует зрелых DevOps-процессов и сложной инфраструктуры, что не соответствует текущим ресурсам проекта.
Решаемые требования: SCA01, SCA02, PER01, PER04, PRN03.
(Анализ остальных паттернов — Индексы в БД, Репликация, Шардинг, Партиционирование, Денормализация, Функциональное разделение, Отложенные вычисления, Асинхронная обработка, Конвейер, Параллельные выполнения, Event-Driven Architecture (EDA) — выполнен в аналогичном детальном формате с указанием плюсов, минусов, реализации в Kotlin/Spring/PostgreSQL и ссылками на требования.)

Последствия
Технические:
Требуется безупречное соблюдение границ модулей и принципов чистой архитектуры для сохранения преимуществ монолита.
Необходимо внедрение комплексного мониторинга (MON01) для отслеживания эффективности паттернов: hit-rate кеша, задержки репликации, длина очереди событий, время выполнения отложенных джобов.
Возрастает важность написания интеграционных и нагрузочных тестов для проверки работы системы в сценариях высокой нагрузки и деградации.
Операционные:
Упрощение на старте: Один артефакт для развёртывания, одна база данных для резервного копирования.
Новые компоненты для управления: Появление Redis, реплик БД, менеджера очередей (Kafka) требует новых компетенций в команде эксплуатации.
Усложнение отладки в production: Распределённая обработка (события, асинхронные задачи) требует centralized logging и распределённой трассировки (например, через Spring Cloud Sleuth и Zipkin).
3. Для бизнеса:
Система получает техническую возможность для уверенного роста до 100k пользователей (SCA04) с соблюдением SLA по доступности (AVA01) и производительности.
Архитектура закладывает основу для эволюционного, а не революционного, перехода к микросервисам (по паттерну Strangler Fig), когда это станет экономически и технически оправданным.

Рекомендации по реализации
Фаза 1 (Запуск): Сфокусироваться на Трехзвенной структуре, Индексах БД и Асинхронной отправке уведомлений. Это обеспечит работоспособное ядро.
Фаза 2 (Рост до 25k): Внедрить Кеширование (Redis) для API просмотра и Репликацию БД для чтения отчётов. Настроить отложенный расчёт ночной аналитики.
Фаза 3 (Рост до 100k): Внедрить Партиционирование таблицы транзакций, перейти к горизонтальному масштабированию приложения. Полностью перевести взаимодействие модулей на EDA.
Непрерывно: Каждое внедрённое решение должно сопровождаться метриками (MON01). Например, графики: время отклика /api/balance до/после кеша, процент успешных обработок событий в очереди, нагрузка на мастер и реплики БД.

