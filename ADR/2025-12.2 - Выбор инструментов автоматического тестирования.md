ADR: 2025-12.2 - Выбор инструментов автоматического тестирования

Дата: 10 декабря 2025 г.
Статус: Принято

Контекст:

Для обеспечения качества и надежности системы управления лояльностью клиентов необходимо внедрить комплексную систему автоматического тестирования. Тестирование должно охватывать:

Модульное тестирование бизнес-логики и отдельных компонентов

Интеграционное тестирование взаимодействия между модулями и внешними системами

End-to-end тестирование пользовательских сценариев

Нагрузочное тестирование для проверки производительности

Тестирование безопасности и аудита операций

Рассмотренные варианты:

JUnit 5 + Kotest + MockK — для модульного и интеграционного тестирования бэкенда

TestContainers + Spring Boot Test — для интеграционного тестирования с реальными базами данных

Cypress + Testing Library — для E2E тестирования фронтенда

Playwright — для кросс-браузерного и кросс-платформенного тестирования

JMeter + Gatling — для нагрузочного тестирования

OWASP ZAP — для тестирования безопасности

Решение:

Выбран комплексный стек инструментов:

Модульное тестирование: Kotest + MockK

Интеграционное тестирование: Spring Boot Test + TestContainers

E2E тестирование фронтенда: Playwright + React Testing Library

Нагрузочное тестирование: Gatling

Тестирование безопасности: OWASP ZAP + кастомные тесты безопасности

Обоснование:

Kotest для модульного тестирования:

Специализированная поддержка Kotlin с улучшенным DSL

Property-based testing для проверки инвариантов бизнес-логики

Лучшая интеграция с корутинами Kotlin

Читабельные отчеты об ошибках

Spring Boot Test + TestContainers для интеграционного тестирования:

Тестирование с реальными зависимостями (PostgreSQL, Redis, очереди)

Изоляция тестов через Docker-контейнеры

Поддержка транзакционных тестов для проверки операций с баллами

Playwright для E2E тестирования:

Поддержка всех современных браузеров (Chrome, Firefox, Safari, Edge)

Надежные селекторы и автоматическое ожидание элементов

Возможность тестирования мобильных viewport

Поддержка нескольких доменов (клиентский и административный интерфейсы)

Gatling для нагрузочного тестирования:

DSL на Scala, но с хорошей поддержкой HTTP-протокола

Детальные отчеты о производительности

Возможность моделирования сложных пользовательских сценариев

Интеграция с CI/CD

OWASP ZAP для безопасности:

Автоматическое сканирование уязвимостей

API для интеграции в pipeline

Поддержка современных веб-технологий

Архитектура тестирования:
┌─────────────────────────────────────────────────────────────┐
│                    Уровни тестирования                       │
├─────────────────┬─────────────────┬─────────────────────────┤
│   Модульное     │  Интеграционное  │        E2E              │
│  Kotest/MockK   │ TestContainers   │     Playwright         │
│   (70% coverage)│  (API, БД, очереди)│  (критические сценарии) │
├─────────────────┴─────────────────┴─────────────────────────┤
│           Нагрузочное тестирование (Gatling)                 │
│           Тестирование безопасности (OWASP ZAP)              │
└─────────────────────────────────────────────────────────────┘
Критические тестовые сценарии:

Операции с бонусными баллами:

Начисление баллов за покупку

Списание баллов для скидки

Проверка целостности баланса

Безопасность и аудит:

Тестирование контроля доступа по ролям

Проверка журналирования критических операций

Тестирование защиты от инъекций и XSS

Интеграции:

Тестирование взаимодействия с платежными системами

Проверка отправки уведомлений

Тестирование API для внешних систем

Преимущества выбранного стека:

Полное покрытие всех уровней приложения

Интеграция с существующим стеком (Kotlin, React)

Поддержка современных практик тестирования

Хорошая документация и сообщество

Возможность запуска в CI/CD pipeline

Недостатки и риски:

Сложность настройки и поддержки нескольких инструментов

Высокие требования к вычислительным ресурсам для тестов

Кривая обучения для новых членов команды

Смягчающие меры:

Поэтапное внедрение с приоритетом критических функций

Создание шаблонов и boilerplate кода для тестов

Регулярный ревью тестов на качество и эффективность

Мониторинг времени выполнения тестовой сборки

Последствия:

Для разработки:

Внедрение Test-Driven Development для критического функционала

Создание мок-серверов для внешних интеграций

Разработка тестовых данных и фикстур

Для инфраструктуры:

Настройка Docker-окружения для тестов

Конфигурация CI/CD pipeline для запуска тестов

Мониторинг покрытия тестами и качества кода

Для процесса:

Требование тестов для новых функций

Регулярный прогон регрессионных тестов

Периодическое обновление тестовых сценариев

Для качества:

Установка минимальных требований к покрытию кода

Мониторинг ложноположительных срабатываний тестов

Регулярный анализ упавших тестов

Метрики успеха:

Покрытие кода модульными тестами ≥ 70%

Время выполнения полного набора тестов < 30 минут

Zero critical bugs в production за квартал

Успешное прохождение нагрузочных тестов с целевыми показателями

Отсутствие уязвимостей безопасности, обнаруженных автоматическими сканерами